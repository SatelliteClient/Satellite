package com.github.satellite.features.module.exploit;

import com.github.satellite.Satellite;
import com.github.satellite.network.packet.Packet;
import com.github.satellite.network.packet.packets.*;
import com.github.satellite.event.Event;
import com.github.satellite.event.listeners.EventRecieveSateNet;
import com.github.satellite.event.listeners.EventUpdate;
import com.github.satellite.features.module.Module;
import com.github.satellite.features.test.botting.BotEvent;
import com.github.satellite.features.test.botting.listeners.Fill;
import com.github.satellite.features.test.botting.listeners.Goto;
import com.github.satellite.features.test.botting.listeners.Refill;
import com.github.satellite.utils.MovementUtils;
import net.minecraft.block.Block;
import net.minecraft.block.BlockAir;
import net.minecraft.block.state.IBlockState;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;
import org.lwjgl.input.Keyboard;

import java.util.concurrent.CopyOnWriteArrayList;

public class Bot extends Module {

	public Bot() {
		super("Bot", Keyboard.KEY_NONE, Category.EXPLOIT, true);
	}

	@Override
	public void init() {
		this.tasks = new CopyOnWriteArrayList<BotEvent>();
		super.init();
	}

	CopyOnWriteArrayList<BotEvent> tasks;

	public BlockPos stash;

	@Override
	public void onEvent(Event<?> e) {
		if(e instanceof EventRecieveSateNet) {
			EventRecieveSateNet event = (EventRecieveSateNet)e;
			Packet p = event.getData();
			if(p instanceof SPGoto) {
				SPGoto packet = (SPGoto)p;
				tasks.add(new Goto(packet.getX(), packet.getY(), packet.getZ()));
			}
			if(p instanceof SPChangeBlockAction) {
				SPChangeBlockAction packet = (SPChangeBlockAction)p;
				tasks.add(new Fill(packet.getX(), packet.getY(), packet.getZ(), packet.getX(), packet.getY(), packet.getZ(), packet.getAction()));
			}
			if(p instanceof SPFillBlocks) {
				SPFillBlocks packet = (SPFillBlocks)p;
				tasks.add(new Fill(packet.getX1(), packet.getY1(), packet.getZ1(), packet.getX2(), packet.getY2(), packet.getZ2(), packet.getBlock()));
			}
			if (p instanceof SPRefillPoint) {
				SPRefillPoint packet = (SPRefillPoint)p;
				this.stash = packet.getBlockPos();
			}
			if (p instanceof SPClear) {
				tasks.clear();
			}
		}
		if(e instanceof EventUpdate) {
			if(tasks.isEmpty())
				return;
			if(tasks.get(0) instanceof Refill) {
				Refill refill = (Refill)tasks.get(0);
				tasks.add(new Goto(stash.getX(), -1, stash.getZ()));
				tasks.remove(0);
			}
			if(tasks.isEmpty())
				return;
			if(tasks.get(0) instanceof Fill) {
				Fill task = (Fill)tasks.get(0);
				int height = isFilledAndHeight(task.x1, task.z1, task.y1, task.y2, task.block);

				if (height == task.y2)
					tasks.remove(0);

				BlockPos currentPos = new BlockPos(task.x1, mc.world.getHeight(task.x1, task.z1), task.z1);

				double dx = task.x1 + .5D - mc.player.posX,
				       dz = task.z1 + .5D - mc.player.posZ,
				       dy = currentPos.getY() + 2 - mc.player.posY;

				if (dx == 0 && dz == 0 && Math.abs(dy) < 2) {
					if (currentPos.getY()-1 < height) {
						/*BlockUtils block = new BlockUtils(currentPos, 0, EnumFacing.UP, 0);
						if (block != null) {
							block.doPlace(false);
						}*/
						mc.playerController.processRightClickBlock(mc.player, mc.world, currentPos.offset(EnumFacing.DOWN), EnumFacing.UP, new Vec3d(0, -1, 0), EnumHand.MAIN_HAND);
					}else {
						if (mc.playerController.onPlayerDamageBlock(currentPos.offset(EnumFacing.DOWN), EnumFacing.UP)) {
							MovementUtils.vClip(-1);
						}
					}
				}

				mc.player.motionX = Math.max(-1, Math.min(dx, 1));
				mc.player.motionZ = Math.max(-1, Math.min(dz, 1));
				mc.player.motionY = Math.max(-1, Math.min(dy, 1));

			}
			if(tasks.isEmpty())
				return;
			if(e.isPre()) {
				if(tasks.get(0) instanceof Goto) {
					Goto gOto = (Goto)tasks.get(0);
					double dx = gOto.getX()+0.5 - mc.player.posX,
							dz = gOto.getZ()+0.5 - mc.player.posZ,
							dy = (dx==0&&dz==0?(gOto.getY()==-1?mc.world.getHeight(gOto.getX(), gOto.getZ()): gOto.getY()):255) - mc.player.posY,
							dist = Math.sqrt(dx*dx+dz*dz),
							h = dist>1?1:dist;
					h = dy==0?h:0;
					mc.player.motionX=h*Math.sin(Math.atan2(dx, dz));
					mc.player.motionZ=h*Math.cos(Math.atan2(dx, dz));
					mc.player.motionY=Math.max(Math.min(dy, 1), -1);
					MovementUtils.move();
					MovementUtils.freeze();
					if(dx==0&&dz==0&&dy==0) tasks.remove(0);
					if(mc.player.collidedHorizontally) tasks.remove(0);
				}

			}
			if (Satellite.isConnected) {
				Satellite.SatelliteNet.netWorkManager.sendPacket(new CPPosition((int)mc.player.posX, (int)mc.player.posY, (int)mc.player.posZ));
			}
		}
		super.onEvent(e);
	}

	public int isFilledAndHeight(int x, int z, int y1, int y2, int block) {
		for(int y = y1; y <= y2; y++) {
			BlockPos pos = new BlockPos(x, y, z);
			if(!(mc.world.getBlockState(pos).getBlock() == Block.getBlockById(block))) {
				return y;
			}
		}
		return y2;
	}

	public int getHeight(int x, int z) {
		for(int y = 255; y >= 0; y--) {
			BlockPos pos = new BlockPos(x, y, z);
			IBlockState iblockstate = mc.world.getBlockState(pos);
			if(!(iblockstate instanceof BlockAir)) {
				return y;
			}
		}
		return 255;
	}

	public enum BotTask {
		GOTO,
		FILL,
		REFILLITEMS,
		DONE;
	}
}
